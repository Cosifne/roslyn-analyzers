# Should the analyzer only report diagnostic when multiple calls to MoveNext() could be avoided or when MoveNext() is called?

There are two similar, but different scenarios could be covered by this analyzer,
1. Many Linq methods provide an short-cut before calling into 'MoveNext()' method, which iterates over the collection. Like [Count](https://github.com/dotnet/runtime/blob/59e643b9932122a12e71ceb360a9ae3bb9420dec/src/libraries/System.Linq/src/System/Linq/Count.cs#L18), [Last](https://github.com/dotnet/runtime/blob/59e643b9932122a12e71ceb360a9ae3bb9420dec/src/libraries/System.Linq/src/System/Linq/Last.cs#L76), [ElementAt](https://github.com/dotnet/runtime/blob/59e643b9932122a12e71ceb360a9ae3bb9420dec/src/libraries/System.Linq/src/System/Linq/ElementAt.cs#L27), [Any](https://github.com/dotnet/runtime/blob/59e643b9932122a12e71ceb360a9ae3bb9420dec/src/libraries/System.Linq/src/System/Linq/AnyAll.cs#L18). These method would try type cast the IEnumerable instance to ICollection, try use the indexer to find the element. Trying cast or covert the collection to an array/list could potentially reduce the cost of these operations from O(n) to O(1).
This means, the analyzer should only report diagnostic when calling these methods twice or more, example:
```
void Bar(IEnumerable<int> i)
{
    var j = i.ElementAt(10);
    var k = i.Count();
}
```
Diagnostic should be reported under `i`, because if `i` is converted to array/list, the both operations could be performed by using the indexing operation.
But for
```
void Bar(IEnumerable<int> i)
{
    var j = i.Aggregate((a, b) => a + b);
    var k = i.SequenceEqual(j);
}
```
No diagnostic should be reported because even if `i` is converted to array/list, it would still be enumerated twice.
And for
```
void Bar(IEnumerable<int> i)
{
    var j = i.Aggregate((a, b) => a + b);
    var k = i.Count();
}
```
No need to report diagnostic for this case, because  `i.Count()` cost O(n), and convert `i` to an array will also cost O(n).
Also The call to `First()`, `Single()` ... should not generate the diagnostic, because they call 'MoveNext()' method once, the cost is nearly O(1), convert it to an array would not be helpful.

2. Linq methods might be misused in a way which generates unexpected results if it is querying info into Database or some other data sources multiple times. Example:
```
void Bar()
{
    IEnumerable<string> collection = QueryDataFromWebOrDB();
    var firstItem = collection.First();
    // Do other stuff
    var firstItemAgain = collection.First();
}
```

The value of `firstItemAgain` might be different from `firstItem`, if the code in the middle modifies the data source, which generates unexpected bugs.
It could also be harmful to perf, if querying to the data source itself is time-consuming.
This means, diagnostic needs to reported even when 'MoveNext()' is called once. (For both `collection` in the previous example)
But from the perspective of case1, it is not needed, because converting/cast `collection` to an array won't saving anything when call `First()`
A real world [example](https://github.com/dotnet/runtime/blob/0c3a6ee42276d9ba68954eb00f55c46ddf27fb39/src/libraries/System.Runtime.InteropServices/gen/Microsoft.Interop.SourceGeneration/IGeneratorDiagnostics.cs#L44-L49) in runtime repo
```
    public static Diagnostic CreateDiagnostic(
    this ImmutableArray<Location> locations,
    DiagnosticDescriptor descriptor,
    params object[] args)
{
    IEnumerable<Location> locationsInSource = locations.Where(l => l.IsInSource);
    if (!locationsInSource.Any())
        return Diagnostic.Create(descriptor, Location.None, args);

    return Diagnostic.Create(
        descriptor,
        location: locationsInSource.First(),
        additionalLocations: locationsInSource.Skip(1),
        messageArgs: args);
}
```
`locationsInSource` is not needed to be reported for case1, but it is needed in case2.

The diagnostics generated by this case would be a superset of the previous one.